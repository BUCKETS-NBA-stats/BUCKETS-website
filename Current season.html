<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>2024-25 season</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<title>2024-25</title>
		
		<!-- jquery-->
		<script src="assets/js/jquery.min.js"></script>
 	   
		<!-- Select2-->
		<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/js/select2.min.js"></script>

    	<!-- DataTables CSS -->
		<link rel="stylesheet" href="https://cdn.datatables.net/v/dt/dt-2.1.8/date-1.5.4/fh-4.0.1/sb-1.8.1/datatables.min.css">

		<!-- DataTables JS -->
		<script src="https://cdn.datatables.net/v/dt/dt-2.1.8/date-1.5.4/fh-4.0.1/sb-1.8.1/datatables.min.js"></script>

		<!-- Papa Parse CSV parser -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

		<!-- Select2 CSS -->
		<link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/css/select2.min.css" rel="stylesheet" />

		<style>
			/* Table styling */
			#playerTable {
				width: 100%;
				table-layout: fixed;
				overflow: hidden;
				border-collapse: separate !important;
				border-spacing: 0; /* Ensures no extra spacing between cells */
			}
		
			#playerTable td:nth-child(1), /* Player column */
			#playerTable td:nth-child(4) /* Total PC/g column */ 
			{
				font-weight: bold;
			}

			#playerTable th[colspan="2"] {
    			text-align: center;
			}

			#playerTable th[colspan="4"] {
    			text-align: center;
			}

			#playerTable th:nth-child(1), 
			#playerTable td:nth-child(1) {
				width: 280px; /* Adjust as needed*/
				white-space: nowrap; /* Prevent wrapping */
			}

			.select2-selection__clear {
    			line-height: 1 !important;
				padding-left: 10px !important;
				width: 40px !important;
				padding-right: 10px !important;
				align-items: center !important;
    			justify-content: center !important;
			}

			/* Add a thin gray line to the right of the specified columns */
			/* Add a thin gray line to the right of the specified columns */
			#playerTable td.group-separator,
			#playerTable th.group-separator {
				border-right: 1px solid #0000004D !important;
			}

			/* Custom controls */
			.custom-controls {
				display: flex;
				align-items: center;
			}

			.top-controls {
    			margin-bottom: 20px; /* Adjust the value as needed */
			}

			/* Optional: make sure the main content doesn’t overflow the sidebar */
			#main {
				overflow-x: auto;
			}
		</style>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="index.html" class="logo"><strong>BUCKETS</strong> NBA Stats</a>
									<ul class="icons">
										<li><a href="twitter.com" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
										<li><a href="mailto:BUCKETS.stat@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
									</ul>
								</header>

							<!-- Table -->
								
							<h2>2024-25 Summary</h2>
							<h4>Updated Feb 10, 2025</h4>
							<p>Notable missing data: Transition for Cade, AD, Ty Jerome, Jarrett Allen; All data for Hartenstein and DLo</p>
						
							<!-- Drop down selector -->
							<!-- <label for="teamSelect">Select Team:</label> -->
							<!-- <select id="teamSelect">
								<option value="">--Enter here--</option>
							</select> -->
					
							<!-- <label for="yearSelect">Select Year:</label> -->
							<!-- <select id="yearSelect">
								<option value="">--Enter here--</option>
							</select> -->

							<!-- Drop down selector for unit -->
							<div id="unit-dropdown">
								<label for="statUnitSelect">Unit:</label>
								<select id="statUnitSelect">
									<option value="per game" selected>per game</option>
									<option value="per 36 minutes">per 36 minutes</option>
									<option value="per 75 possessions">per 75 possessions</option>
								</select>
							</div>


							<!-- Table for DataTables -->
							<div class="table-container" style="overflow-x: auto;">
								<table id="playerTable" class="display compact">
									<thead>
										<tr>
										  <th rowspan="2">Player</th>
										  <th rowspan="2">Tm</th>
										  <th rowspan="2">G</th>
										  <th colspan="4">Total</th>
										  <th colspan="2">On-ball</th>
										  <th colspan="2">Off-ball</th>
										  <th colspan="2">Transition</th>
										  <th colspan="3" class="unit-components" data-base="Components of Total PC">Components of Total PC</th>
										</tr>
										<tr>
										  <!-- Total -->
										  <th title="Points Created: Total points added vs baseline efficiency" class="unit-pc" data-base="PC">PC/g</th>
										  <th title="Total Usage: % of possessions where the player had a scoring attempt, potential assist, or turnover">Usage</th>
										  <th title="Points Responsible For: Total scored and assisted points including FT" class="unit-prf" data-base="PRF">PRF/g</th>
										  <th title="Relative Offensive Rating: Points per 100 plays above baseline">rORTG</th>
										  <!-- On-ball -->
										  <th title="Points Responsible For: Total scored and assisted points including FT" class="unit-prf" data-base="PRF">PRF/g</th>
										  <th title="Points Created: Total points added vs baseline efficiency. For on-ball, baseline is league average half court offensive rating and points added includes floor raising value" class="unit-pc" data-base="PC">PC/g</th>
										  <!-- Off-ball -->
										  <th title="Points Responsible For: Total scored and assisted points including FT" class="unit-prf" data-base="PRF">PRF/g</th>
										  <th title="Points Created: Total points added vs baseline efficiency. For off-ball, baseline is average PPP for the play type" class="unit-pc" data-base="PC">PC/g</th>
										  <!-- Transition -->
										  <th title="Points Responsible For: Total scored and assisted points including FT" class="unit-prf" data-base="PRF">PRF/g</th>
										  <th title="Points Created: Total points added vs baseline efficiency. For transition, baseline is set based on transition volume" class="unit-pc" data-base="PC">PC/g</th>
										  <!-- Components -->
										  <th title="Points created from scoring more efficiently than baseline">Scoring</th>
										  <th title="Points created from playmaking more efficiently than baseline">Playmaking</th>
										  <th title="Points created from displacing lower value on-ball possessions (with random teammates)">Floor raising</th>
										</tr>
									  </thead>									  
									<tbody>
										<!-- Data from CSV will be loaded here -->
									</tbody>
								</table>
							</div>
							<script>
								var table;
								var prfMinMax = {};
								var rortgMinMax = {};
								var pcMinMax = {}; // Store calculated min/max for Total PC/g
								var currentUnit = "per game"; // Default is per game

								function convertUnitToPCUnit(unit) {
									if (unit === "per game") return "PC/g";
									if (unit === "per 36 minutes") return "PC/36";
									if (unit === "per 75 possessions") return "PC/75";
								}

								function getCurrentPCKeys() {
									var pcUnit = convertUnitToPCUnit(currentUnit);
									if (pcUnit === "PC/g") {
										return [
											'Total PC/g (floor raising adj.)',
											'On-ball PC/g (floor raising adj.)',
											'Off-ball PC/g',
											'Transition PC/g',
											'Scoring PC/g',
											'Playmaking PC/g',
											'Floor raising PC/g'
										];
									} else if (pcUnit === "PC/36") {
										return [
											'Total PC/36 (floor raising adj.)',
											'On-ball PC/36 (floor raising adj.)',
											'Off-ball PC/36',
											'Transition PC/36',
											'Scoring PC/36',
											'Playmaking PC/36',
											'Floor raising PC/36'
										];
									} else if (pcUnit === "PC/75") {
										return [
											'Total PC/75 (floor raising adj.)',
											'On-ball PC/75 (floor raising adj.)',
											'Off-ball PC/75',
											'Transition PC/75',
											'Scoring PC/75',
											'Playmaking PC/75',
											'Floor raising PC/75'
										];
									}
								}


								function convertUnitToPRFUnit(unit) {
									if (unit === "per game") return "PRF/g";
									if (unit === "per 36 minutes") return "PRF/36";
									if (unit === "per 75 possessions") return "PRF/75";
								}

								function getCurrentPRFKeys() {
									var prfUnit = convertUnitToPRFUnit(currentUnit);
									return [
										'Total ' + prfUnit,
										'On-ball ' + prfUnit,
										'Off-ball ' + prfUnit,
										'Transition ' + prfUnit
									];
								}


								function updateTableData() {
									var pcKeys = getCurrentPCKeys();   // Returns dynamic PC column keys based on the current unit
									var prfKeys = getCurrentPRFKeys(); // Returns dynamic PRF column keys based on the current unit

									var filteredData = window.fullCSVData.filter(row => {
										const possessions = parseFloat(row['Possessions'].trim());
										return !isNaN(possessions) && possessions >= 600;
									});

									const formattedData = filteredData.map(row => [
										row['Player'],                   // index 0
										row['Tm'],                       // index 1
										row['Games'],                    // index 2
										row[pcKeys[0]],                  // index 3: Total PC/g
										row['Total usage %'],            // index 4: Total usage % (constant)
										row[prfKeys[0]],                 // index 5: Total PRF/g
										row['Total rORTG'],              // index 6: Total rORTG
										row[prfKeys[1]],                 // index 7: On-ball PRF/g
										row[pcKeys[1]],                  // index 8: On-ball PC/g
										row[prfKeys[2]],                 // index 9: Off-ball PRF/g
										row[pcKeys[2]],                  // index 10: Off-ball PC/g
										row[prfKeys[3]],                 // index 11: Transition PRF/g
										row[pcKeys[3]],                  // index 12: Transition PC/g
										row[pcKeys[4]],                  // index 13: Scoring PC/g
										row[pcKeys[5]],                  // index 14: Playmaking PC/g
										row[pcKeys[6]]                   // index 15: Floor raising PC/g
									]);

									table.clear();
									table.rows.add(formattedData);
									table.order([3, 'desc']).draw();
								}

								// Map displayed table columns to their respective CSV keys
								const tableToCsvMap = {
									prf: [
										'Total PRF/g', 
										'On-ball PRF/g', 
										'Off-ball PRF/g', 
										'Transition PRF/g'
									],
									pc: [
										'Total PC/g (floor raising adj.)', 
										'On-ball PC/g (floor raising adj.)', 
										'Off-ball PC/g', 
										'Transition PC/g',
										'Scoring PC/g',
										'Playmaking PC/g',
										'Floor raising PC/g'
									],
									rortg: [
										'Total rORTG', 
										'On-ball rORTG', 
										'Off-ball rORTG', 
										'Transition rORTG'
									],
									playsPerGame: [
										'Total Plays/g',
										'On-ball Plays/g',
										'Off-ball Plays/g',
										'Transition Plays/g'
									]
								};

							
								// Helper function for linear gradient
								function getGradientColor(value, min, max, colorStart, colorEnd) {
									let ratio = (value - min) / (max - min); // Normalize to [0, 1]
									ratio = Math.max(0, Math.min(1, ratio)); // Clamp ratio between 0 and 1
									const start = hexToRgb(colorStart);
									const end = hexToRgb(colorEnd);
									const r = Math.round(start.r + ratio * (end.r - start.r));
									const g = Math.round(start.g + ratio * (end.g - start.g));
									const b = Math.round(start.b + ratio * (end.b - start.b));
									return `rgb(${r}, ${g}, ${b})`;
								}
							
								// Helper function for diverging gradient
								function getDivergingGradient(value, min, max, colorLow, colorZero, colorHigh) {
									if (value === 0) return colorZero;
							
									// Normalize and clamp the value
									if (value > 0) {
										const clampedValue = Math.min(value, max); // Clamp positive value to max
										return getGradientColor(clampedValue, 0, max, colorZero, colorHigh);
									} else {
										const clampedValue = Math.max(value, min); // Clamp negative value to min
										return getGradientColor(clampedValue, min, 0, colorLow, colorZero);
									}
								}
							
								// Convert hex to RGB
								function hexToRgb(hex) {
									const bigint = parseInt(hex.slice(1), 16);
									return {
										r: (bigint >> 16) & 255,
										g: (bigint >> 8) & 255,
										b: bigint & 255
									};
								}
							
								// Compute min/max for PRF/g, rORTG, and Total PC/g
								function computeColumnMinMax(data) {
									var prfKeys = getCurrentPRFKeys();
									var pcKeys = getCurrentPCKeys();
									const rortgKeys = tableToCsvMap.rortg;
									const playsPerGameKeys = tableToCsvMap.playsPerGame;
									const totalPlaysKey = 'Possessions';
									
									// Compute min/max for PRF columns
									prfKeys.forEach((key, i) => {
										const columnValues = data
										.map(row => parseFloat(row[key]))
										.filter(v => !isNaN(v));
										if (columnValues.length > 0) {
											prfMinMax[key] = {
												min: Math.min(...columnValues),
												max: Math.max(...columnValues)
											};
										}
									});
									
									// Compute min/max for Total usage % column (constant, no unit conversion)
									const usageValues = data
										.map(row => parseFloat(row['Total usage %']))
										.filter(v => !isNaN(v));
									if (usageValues.length > 0) {
										prfMinMax['Total usage %'] = {
											min: Math.min(...usageValues),
											max: Math.max(...usageValues)
										};
									}


									// Compute min/max for PC columns
									pcKeys.forEach((key, i) => {											
										const columnValues = data
										.filter(row => {
											const totalPlays = parseFloat(row[totalPlaysKey]);
											return totalPlays >= 600;
										})
										.map(row => parseFloat(row[key]))
										.filter(v => !isNaN(v));
										if (columnValues.length > 0) {
											pcMinMax[key] = {
												min: Math.min(...columnValues),
												max: Math.max(...columnValues)
											};
										}
									});
							
									// Calculate rORTG min and max, excluding rows with low data and additional logic
									rortgKeys.forEach((key, i) => {
										const columnValues = data
											.filter(row => {
												const totalPlays = parseFloat(row[totalPlaysKey]); // Total possessions
												const playsPerGame = parseFloat(row[playsPerGameKeys[i]]); // Corresponding Plays/g
						
												// Exclude rows with low data
												return totalPlays >= 600 && playsPerGame >= 5;
											})
											.map(row => parseFloat(row[key]))
											.filter(v => !isNaN(v)); // Exclude invalid values
						
										if (columnValues.length > 0) {
											rortgMinMax[key] = {
												min: Math.min(...columnValues),
												max: Math.max(...columnValues)
											};
										} else {
											console.warn(`No valid data for rORTG column: ${key}`);
										}
									});
							
									console.log("PRF MinMax:", prfMinMax);
									console.log("PC MinMax:", pcMinMax);
									console.log("rORTG MinMax:", rortgMinMax);
								}

								function updateHeaderUnits() {
									// Determine the suffix based on the current unit.
									var suffix;
									if (currentUnit === "per game") {
										suffix = "/g";
									} else if (currentUnit === "per 36 minutes") {
										suffix = "/36";
									} else if (currentUnit === "per 75 possessions") {
										suffix = "/75";
									}

									// Update all header cells for PC
									$("#playerTable thead th.unit-pc").each(function() {
										var base = $(this).attr("data-base");
										$(this).text(base + suffix);
									});

									// Update all header cells for PRF
									$("#playerTable thead th.unit-prf").each(function() {
										var base = $(this).attr("data-base");
										$(this).text(base + suffix);
									});

									// Update the header cell for "Components of total PC"
									$("#playerTable thead th.unit-components").each(function() {
										var base = $(this).attr("data-base");
										$(this).text(base + suffix);
									});
								}

								$(document).ready(function () {
									console.log("Document ready – initializing DataTable and loading CSV data...");

									// Initialize the DataTable
									table = $('#playerTable').DataTable({
										paging: false,
										searching: true,
										info: false,
										responsive: true,
										fixedHeader: true,
										autoWidth: true,
										ordering: true,
										dom: "<'row top-controls'<'col-sm-6'f><'col-sm-6 custom-controls'>>rt<'row'<'col-sm-6'i><'col-sm-6'p>>",
										columnDefs: [
											{
												targets: 0,
												width: "200px",
												className: "nowrap",
												render: function (data, type, row) {
													if (type === 'display') {
														const playerUrl = `player%20career.html?player=${encodeURIComponent(data)}`;
														return `<a href="${playerUrl}">${data}</a>`;
													}
													return data;
												}
											},
											{
												// PC columns: indices 3, 8, 10, 12, 13, 14, 15
												targets: [3, 8, 10, 12, 13, 14, 15],
												render: function (data, type, row) {
													if (!data || isNaN(data)) return '';
													return parseFloat(data).toFixed(2);
												}
											},
											{
												// Total usage % column at index 4
												targets: 4,
												render: function(data, type, row) {
													if (!data) return '';
													// Remove a trailing '%' if present and parse the numeric portion.
													var numeric = parseFloat(data.toString().replace('%',''));
													if (isNaN(numeric)) return data; // Fallback if parsing fails
													return numeric.toFixed(1) + '%';
												}
											},
											{
												// Other PRF columns (Total PRF/g, On-ball PRF/g, Off-ball PRF/g, Transition PRF/g)
												targets: [5, 7, 9, 11],
												render: function (data, type, row) {
													if (!data || isNaN(data)) return '';
													return parseFloat(data).toFixed(1);
												}
											},

											{
												// rORTG column: index 6
												targets: [6],
												render: function (data, type, row) {
													if (!data || isNaN(data)) return '';
													var num = parseFloat(data).toFixed(1);
													return num > 0 ? '+' + num : num;
												}
											},
											// Group separators after: index 2 (Games), index 6 (Total group),
											// index 8 (On-ball), index 10 (Off-ball), index 12 (Transition)
											{ targets: [2], className: 'group-separator' },
											{ targets: [6], className: 'group-separator' },
											{ targets: [8], className: 'group-separator' },
											{ targets: [10], className: 'group-separator' },
											{ targets: [12], className: 'group-separator' }
										],

										createdRow: function (row, rowData) {
											// PC: [3, 8, 10, 12, 13, 14, 15]
											// PRF: [4, 5, 7, 9, 11]  (note: index 4 is for Total usage %)
											// rORTG: [6]
											const pcIndices = [3, 8, 10, 12, 13, 14, 15];
											const prfIndices = [4, 5, 7, 9, 11];
											const rortgIndices = [6];

											function adjustTextColor(backgroundColor) {
												if (!backgroundColor || !backgroundColor.match(/\d+/g)) {
													return '#3d4449';
												}
												const rgb = backgroundColor.match(/\d+/g).map(Number);
												const luminance = (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) / 255;
												return luminance > 0.5 ? '#3d4449' : '#f5f5f5';
											}

											// Format PC cells
											pcIndices.forEach((index, i) => {
												const csvKey = getCurrentPCKeys()[i];
												const pcValue = parseFloat(rowData[index]);
												if (pcMinMax[csvKey] && !isNaN(pcValue)) {
													const pcColor = getDivergingGradient(
														pcValue,
														pcMinMax[csvKey].min,
														pcMinMax[csvKey].max,
														'#cc6600',
														'#ffffff',
														'#006622'
													);
													const textColor = adjustTextColor(pcColor);
													$('td', row).eq(index).css({ 'background-color': pcColor, 'color': textColor });
												}
											});

											// Format PRF cells (including the constant Total usage % column)
											prfIndices.forEach((index) => {
												let csvKey;
												if (index === 4) {
													// For index 4, use the constant CSV key for Total usage %
													csvKey = 'Total usage %';
												} else if (index === 5) {
													csvKey = getCurrentPRFKeys()[0]; // Total PRF/g
												} else if (index === 7) {
													csvKey = getCurrentPRFKeys()[1]; // On-ball PRF/g
												} else if (index === 9) {
													csvKey = getCurrentPRFKeys()[2]; // Off-ball PRF/g
												} else if (index === 11) {
													csvKey = getCurrentPRFKeys()[3]; // Transition PRF/g
												}
												const prfValue = parseFloat(rowData[index]);
												if (prfMinMax[csvKey]) {
													const prfColor = getGradientColor(
														prfValue,
														prfMinMax[csvKey].min,
														prfMinMax[csvKey].max,
														'#ffffff',
														'#006622'
													);
													const textColor = adjustTextColor(prfColor);
													$('td', row).eq(index).css({ 'background-color': prfColor, 'color': textColor });
												}
											});


											// Format rORTG cell at index 6
											rortgIndices.forEach((index, i) => {
												const csvKey = tableToCsvMap.rortg[i];
												// For the Total group, use the CSV field "Total Plays/g" if available.
												const totalPlays = parseFloat(row['Total Plays/g'] || 0);
												const rortgValue = parseFloat(rowData[index]);
												if (rortgMinMax[csvKey] && !isNaN(rortgValue) && totalPlays >= 1) {
													const rortgColor = getDivergingGradient(
														rortgValue,
														rortgMinMax[csvKey].min,
														rortgMinMax[csvKey].max,
														'#cc6600',
														'#ffffff',
														'#006622'
													);
													const textColor = adjustTextColor(rortgColor);
													$('td', row).eq(index).css({ 'background-color': rortgColor, 'color': textColor });
												}
											});
										}
									});

									// inject drop down
									$('.custom-controls').append($('#unit-dropdown'));

									
									// Add the event listener for the unit dropdown
									$('#statUnitSelect').on('change', function() {
										currentUnit = $(this).val();
										computeColumnMinMax(window.fullCSVData);
										updateTableData();
										updateHeaderUnits();
									});

									// Load the CSV data using Papa Parse
									Papa.parse('assets/data/league-table-2025.csv', {
										download: true,
										header: true,
										encoding: "UTF-8",
										skipEmptyLines: true,
										complete: function (results) {
											window.fullCSVData = results.data;
											computeColumnMinMax(window.fullCSVData);
											updateTableData();
											updateHeaderUnits();
										},
										error: function (error) {
											console.error("Error loading CSV file:", error);
										}
									});
								});
																
								// Update the table data based on the current unit
								$('#statUnitSelect').on('change', function() {
									currentUnit = $(this).val();
									
									// Recalculate min/max for the new PC and PRF columns.
									computeColumnMinMax(window.fullCSVData);
									
									// Rebuild the table with the new keys.
									updateTableData();
								});
								
							</script>
						</div>
					</div>

				<!-- Sidebar -->
				<div id="sidebar">
					<div class="inner">
						<!-- Search -->
						<section id="search" class="alt">
							<form method="post" action="#">
								<input type="text" name="query" id="query" placeholder="Search" />
							</form>
						</section>

						<!-- Menu -->
						<nav id="menu">
							<header class="major">
								<h2>Menu</h2>
							</header>
							<ul>
								<li><a href="index.html">Homepage</a></li>
								<li>
									<span class="opener">Stats</span>
									<ul>
										<li><a href="player career.html">Player Career</a></li>
										<li><a href="player season.html">Player Season</a></li>
										<li><a href="team summary.html">Team Summary</a></li>
										<li><a href="league table.html">League Leaderboards</a></li>
										<li><a href="bubble chart.html">League Custom charts</a></li>
										<li><a href="all time peaks.html">All-time Peaks</a></li>
									</ul>
								</li>
								<li>
									<span class="opener">Insights</span>
									<ul>
										<li><a href="floor raising.html">The Westbrook Theorem</a></li>
										<li><a href="#">More coming soon</a></li>
									</ul>
								</li>
								<li><a href="methodology.html">Our stats explained</a></li>
							</ul>
						</nav>
						
						<!-- Section -->
						<section>
							<header class="major">
								<h2>Get in touch</h2>
							</header>
							<ul class="contact">
								<li class="icon solid fa-envelope"><a href="mailto:BUCKETS.stat@gmail.com">BUCKETS.stat@gmail.com</a></li>
							</ul>
						</section>
						
						<!-- Footer -->
						<footer id="footer">
							<p class="copyright">&copy; 2024 BUCKETS NBA Stats. All rights reserved. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
						</footer>
					</div>
				</div>
			</div>

			<!-- Scripts -->
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>


	</body>
</html>